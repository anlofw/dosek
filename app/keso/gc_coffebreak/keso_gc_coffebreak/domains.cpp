/* THIS FILE IS AUTO-GENERATED BY KESO! DON'T EDIT */

#include "coffee.h"
#include "keso_types.h"
#include "global.h"
#include "domains.h"


/* heap for domain dom1, size is 1024 */
char __DOSEK_APPDATA_dom1__heap[1024] ALIGN4;

/* Determine the size in slots of the object
 * pointed to by obj
 */
obj_size_t keso_objSize(obj_size_t slot_size, object_pointer obj) {
	obj_size_t size = CLS_SIZE(obj->class_id);

	if(keso_isArrayClass(obj->class_id)) {
		/* element size * element count */
		size *= ((array_t*) obj)->size;
		/* plus size of array header */
		size += sizeof(array_t);
	}

	size += slot_size-1;
	size /= slot_size;
	return size;
}
#define KESO_SEND_GCRUN_EVENTS() do { /* do nothing*/ } while (0)


#ifndef KESO_GCMODE_WORKAHOLIC
/* The GC Task is autostarted; we init the gctpaused field with
 * 0 to prevent task activations during allocations in the startup
 * phase (not allowed by OSEK spec)
 */
unsigned char keso_gctpaused=0;
#endif
TASK(keso_gc_task) {
	while (1) {
#ifndef KESO_GCMODE_WORKAHOLIC
		signed int need = 0;
		if (keso_coffee_main(KESO_GC_DOM1_DDESC!=0)) {
			need=1;
		}

		KESO_SEND_GCRUN_EVENTS();
		if (need==0) {
			keso_gctpaused=1;
			TerminateTask();
		}
#else
		(void)keso_coffee_main(KESO_GC_DOM1_DDESC);

		KESO_SEND_GCRUN_EVENTS();
#endif
	}
} /* END GC TASK */

struct domain_coffee_t __DOSEK_APPDATA_dom1__DDesc = {
	/* init base fields */
	{ /* static refs */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, },
	1024 /* heap_size */,
	1024 /* heap_free */,
	1 /* colorbit */,
	{ /* init heap (type coffee) */
		0 /* sasls */,
		8 /* slotSize */,
		(coffee_listel_t*) (__DOSEK_APPDATA_dom1__heap) /* heap_top */,
		(coffee_listel_t*) (__DOSEK_APPDATA_dom1__heap) /* freemem */,
	},
};


