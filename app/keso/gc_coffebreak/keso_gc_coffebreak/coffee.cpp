/* THIS FILE IS AUTO-GENERATED BY KESO! DON'T EDIT */

#include "coffee.h"
#include "keso_types.h"
#include "global.h"
#include "domains.h"


#define KESO_WAIT_FOR_GCRUN_EVENT() do { /* do nothing*/ } while (0)
#define KESO_GC_DEFER_TASK() do { /* do nothing*/ } while (0)
#define KESO_GC_ROOTSETSIZE (0)
#define KESO_GC_MAXSLOTS (128)
#define KESO_GC_WORKINGSTACK_SIZE (128)
#define BITMAP_SIZE (KESO_GC_MAXSLOTS+sizeof(unsigned int)*8-1)/(sizeof(unsigned int)*8)
static unsigned int keso_bmp_bitmap[BITMAP_SIZE];
#define keso_gc_markSlots keso_bmp_markSlots
#define keso_gc_clearBitmap keso_bmp_clearBitmap
#define keso_gc_findFreeBlock keso_bmp_findFreeBlock
#define MANAGEDDOMAINS 1
#define SET_DDESC(_did_) keso_curdom=(_did_)
#define DOMAINID() (&__DOSEK_APPDATA_dom1__DDesc)
static KESO_TASKCLASSTYPE * KESO_CONST blocking_tasks[] = {
	&__DOSEK_APPDATA_dom1__task1_obj,
};
#define NUM_BLOCKING_TASKS 1

#define GC_LOG_INFO (0)

#define GC_LOG_ALLOC_EVENT(_tid_, _aid_, _class_id_, _freespace_, _size_)

#define GC_LOG_ACTIVATION() do { /* do nothing */ } while(0)
#define GC_LOG_ACTIVATION_ALLOC() do { /* do nothing */ } while(0)

#define GC_LOG_START_EVENT(_did_, _freespace_) do { /* do nothing */ } while(0)
#define GC_LOG_MARK_END_EVENT(_did_, _freespace_) do { /* do nothing */ } while(0)
#define GC_LOG_SWEEP_END_EVENT(_did_, _freespace_) do { /* do nothing */ } while(0)
#define GC_LOG_CLEAR_END_EVENT(_did_, _freespace_) do { /* do nothing */ } while(0)
#define GC_LOG_OUT_OF_MEMORY(_did_, _freespace_) do { /* do nothing */ } while(0)
#define GC_LOG_PMAP_EVENT(_did_, _event_) do { /* do nothing */ } while(0)
#define GC_LOG_ALLOC_START_EVENT(_did_, _freespace_) do { /* do nothing */ } while(0)
#define GC_LOG_ALLOC_END_EVENT(_did_, _freespace_) do { /* do nothing */ } while(0)


/* Mark a sequence of slots beginning at <firstslot> (start counting with 0)
 * with a length of <slotcount> slots in the bitmap.
 */
static void keso_bmp_markSlots(keso_gc_slotcnt_t firstslot, keso_gc_slotcnt_t slotcount) {
	keso_gc_slotcnt_t bmint=firstslot / (sizeof(unsigned int)*8);
	keso_umachineword_t bmbit =firstslot % (sizeof(unsigned int)*8);
	keso_umachineword_t i;

	/* until next full int */
	if(bmbit>0) {
		i = bmbit = sizeof(unsigned int)*8-bmbit;
		if(i>slotcount) i=slotcount;
		slotcount-=i;

		while(i-->0) {
			unsigned int mask = 1<<--bmbit;
			keso_bmp_bitmap[bmint] |= mask;
		}
		bmint++;
	}

	/* full ints */
	while(slotcount >= sizeof(unsigned int)*8) {
		slotcount-=sizeof(unsigned int)*8;
		keso_bmp_bitmap[bmint++] = ~0;
	}

	/* beginning of last partially filled int */
	for(i=sizeof(unsigned int)*8; slotcount>0; slotcount--) {
		keso_bmp_bitmap[bmint] |= 1<<--i;
	}
}

/* Search an int for the first bit with the specified value, starting with
 * bitposition bmbit. Maxsize may limit how much bits are searched, but it
 * is never searched more than to the end of the int.
 *
 * If a bit is found, its offset from bmbit is returned. If not, the negative value
 * of the number of bits searched is returned.
 */
static keso_machineword_t searchInt(keso_gc_slotcnt_t bmint, keso_umachineword_t bmbit, keso_umachineword_t value, keso_umachineword_t maxsize) {
	keso_umachineword_t i;
	keso_machineword_t bitssearched=0;

	/* bmbit used as shiftindex,
	 * i contains number of bits to process */
	bmbit = i = (sizeof(unsigned int)*8)-bmbit;
	if(i>maxsize) i=maxsize;

	while(i-->0) {
		if( ((keso_bmp_bitmap[bmint]>>--bmbit)&1) == value) return bitssearched;
		else bitssearched++;
	}
	return -bitssearched; /* Nothing found */
}

/* Find the first bit that is set to value in the bitmap range starting at
 * bmbegin (counting from 0) with a length of maxsize.
 * The function returns the bitposition, or bmbegin+maxsize if
 * an occurance could not be found in the specified range.
 */
static keso_gc_slotcnt_t keso_bmp_findBit(keso_gc_slotcnt_t bmbegin, keso_gc_slotcnt_t maxsize, keso_umachineword_t value) {
	unsigned int negvalue = ((value==0)?0xffffffff:0);
	keso_gc_slotcnt_t bmbit, bmint;
	keso_machineword_t pos;

	bmint = bmbegin / (keso_gc_slotcnt_t) (sizeof(unsigned int)*8);
	bmbit = bmbegin % (keso_gc_slotcnt_t) (sizeof(unsigned int)*8);

	/* the begin is not on an integer boundary */
	if(bmbit>0) {
		pos = searchInt(bmint, bmbit, value, maxsize);
		if(pos>=0) return (bmbegin+(keso_gc_slotcnt_t) pos);
		pos = -pos;
		bmbegin += (keso_gc_slotcnt_t) pos;
		maxsize -= (keso_gc_slotcnt_t) pos;
		bmint++;
	}

	/* process full ints */
	while(maxsize >= (keso_gc_slotcnt_t) (sizeof(unsigned int)*8)) {
		if(keso_bmp_bitmap[bmint]!=negvalue) break; /* This int contains the searched bit */
		bmint++;
		maxsize -= (keso_gc_slotcnt_t) (sizeof(unsigned int)*8);
		bmbegin += (keso_gc_slotcnt_t) (sizeof(unsigned int)*8);
	}

	if(maxsize > 0) {
		pos = searchInt(bmint, 0, value, maxsize);
		if(pos>=0) return (bmbegin+(keso_gc_slotcnt_t) pos);
		pos = -pos;
		bmbegin += (keso_gc_slotcnt_t) pos;
	}
	return bmbegin;
}

/* Find a block of consecutive unset bits in the bitmap,
 * beginning at position *bmbegin. From bmbegin a maximum
 * of maxsize slots are searched.
 * The function returns the size of the found free block,
 * that may be 0. If there are multiple free blocks in the
 * specified area, the size of the first block is returned.
 * *bmbegin is adjusted to contain the first slot of the
 * free block whose size is returned. If no free block is
 * found, 0 will be returned and *bmbegin will contains its
 * original value + maxsize.
 */
static keso_gc_slotcnt_t keso_bmp_findFreeBlock(keso_gc_slotcnt_t *bmbegin, keso_gc_slotcnt_t maxsize) {
	keso_gc_slotcnt_t blockstart, blockend;
	if(maxsize==0) return 0;
	blockstart = keso_bmp_findBit(*bmbegin, maxsize, 0); /* Find a free slot */
	maxsize -= (blockstart-*bmbegin);
	*bmbegin = blockstart;
	if(maxsize==0) return 0;                    /* No free block in the specified range */
	blockend = keso_bmp_findBit(blockstart, maxsize, 1); /* Find end of free block */
	return blockend-blockstart;                 /* return size of free block */
}

/* Clear bitmap for reuse.
 */
static void keso_bmp_clearBitmap() {
	unsigned int i;
	for(i=0; i < BITMAP_SIZE; i++) {
		keso_bmp_bitmap[i] = 0;
	}
}

#include "keso_exceptions.h"

typedef void (*callback_fkt_t)(object_pointer);

#define LOCKBIT  1
#define REFONHEAP(obj) (heap_begin<=(obj) && (obj)<heap_end)

#define COLORBIT 2

#define OBJCOLORED(obj,cbit) ((obj)->gcinfo == (cbit))
#define COLOROBJ(obj,cbit) ((obj)->gcinfo = (cbit))

#define HEAPDESC (DOMAINID()->hd)
#define BYTES2SLOTS(bytes, slotsize) (((slotsize)-1+(bytes))/(slotsize))
#define ADDR2SLOT(_addr_) ((((unsigned int)(_addr_))-(unsigned int)heap_begin)/HEAPDESC.slotSize)
#define SLOT2ADDR(_slot_) ((char*)heap_begin + (_slot_) * HEAPDESC.slotSize)

/* internal variables */
static object_pointer heap_begin, heap_end;

#ifndef KESO_GCMODE_WORKAHOLIC
extern unsigned char keso_gctpaused;
#endif

/* index in domain[] to currently processed domainid,
 * this is NOT the domainid itself */
static keso_umachineword_t keso_curdom = 0;

#if NUM_BLOCKING_TASKS > 0

#if KESO_FT_LOCAL_REFS_LEVEL > 0 && defined(KESO_FT_GC_USE_PARITY)
	#ifndef KESO_CODED_REF_CXXP_PARITY
		#define CHECK_EOLL(obj) keso_ft_gc_check_eoll(obj)

		void* keso_ft_gc_check_eoll(intptr_t obj){

			if(
				(((intptr_t)obj & 0x2) == 0x2 && ((intptr_t)obj & 0xFFFFFFFC) != 0xFFFFFFFC)
				||
				(((intptr_t)obj & 0x2) != 0x2 && ((intptr_t)obj & 0xFFFFFFFC) == 0xFFFFFFFC)
			){
				obj = KESO_EOLL;
			}

			return (void *) obj;

		}
	#else
		#define CHECK_EOLL(obj) (obj)
	#endif
#else
	#define CHECK_EOLL(obj) (obj)
#endif

static void keso_gc_walk_stack(object_pointer* stack, callback_fkt_t handleObj) {

	if (CHECK_EOLL(stack) == (object_pointer *)KESO_EOLL)
		return; /* empty stack partition */

	/* remove the marker bit */
	stack = keso_unpackStackRef(stack);

	/* Scan linked list of references (llref) */
	while (CHECK_EOLL(*stack) != KESO_EOLL) {
		/* skip null references */
		if (*stack == (void *) 0) {
			stack++;

		/* follow up next frame */
		} else if (keso_isStackRef(*stack)) {
			stack = keso_unpackStackRef(*stack);

		/* process object reference */
		} else {
			ASSERTCLASSID((*stack)->class_id);
			handleObj(*stack);
			stack++;
		}
	}
}
#endif

/* Scan a block that is about to be freed for objects and
 * call the finalize() method of the found objects
 */
#ifdef KESO_NEED_FINALIZE
static void callFinalize(keso_gc_slotcnt_t bstart, keso_gc_slotcnt_t size) {
	object_pointer *blockbegin = (object_pointer*) ((char*)heap_begin +
			( (unsigned int) bstart * (unsigned int) HEAPDESC.slotSize));
	keso_gc_slotcnt_t refsize = (keso_gc_slotcnt_t)
		(((unsigned int) size * (unsigned int) HEAPDESC.slotSize)/(unsigned int) sizeof(object_pointer));
	keso_gc_slotcnt_t index = 0;
	keso_gc_slotcnt_t objbegin=index;
	object_pointer obj;

	while(index < refsize) {
		if( (((unsigned int) blockbegin[index])&1) == 0 ) { index++; continue; }

		obj = (object_pointer)(blockbegin+index);

		ASSERTCLASSID(obj->class_id);

		KESO_ASSERT(CLS_ROFF(obj->class_id)==(index-objbegin));

		/* call finalizer */
		KESO_INVOKE_FINALIZE(obj)(obj);

		/* position behind found object */
		objbegin += keso_objSize(HEAPDESC.slotSize,obj) * (HEAPDESC.slotSize/sizeof(object_pointer));
		index = objbegin;
	}

	KESO_ASSERT(index == refsize && index == objbegin);
}
#endif

#ifdef CLS_ROFF
/* Marks the bits of the slots occupied by @obj.
 * If obj is an object outside the domain heap,
 * nothing is done (immortal objects).
 */
static int keso_gc_markObj(object_pointer obj) {
	if(REFONHEAP(obj)) {
		keso_gc_slotcnt_t firstslot, size;

		/* calculate size in slots (i.e. bits used in the bitmap) */;
		size = keso_objSize(HEAPDESC.slotSize,obj);
		firstslot= ADDR2SLOT((object_pointer*)obj-CLS_ROFF(obj->class_id));

		keso_gc_markSlots(firstslot, size);
		return size;
	}
	return 0;
}

/* Return reference count of an object
 *
 *  x: obj is object array with length x
 *  0: obj has no internal references
 * -x: obj is regular object w/ internal references
 */
static KESO_INLINE int refCnt(object_pointer obj) {
#ifdef KESO_OBJECTARRAYCLASS_AVAILABLE
	if(keso_isObjectArrayClass(obj->class_id))
		return ((array_t*)obj)->size;
#endif
	return -(signed int) CLS_ROFF(obj->class_id);
}
#endif


/* Scan a block that is about to be freed for objects and
 * send tracer-messages
 * TODO this is just a copy of callFinalize (gc-common-llrefs.c)
 *	-> avoid code dupliction (write "iterator"?)
 */
#ifdef KESO_TRACE_OLT
#	ifndef KESO_TRACE_OLT_INACCURATE_FREE
static void traceFreedObjects(keso_gc_slotcnt_t bstart, keso_gc_slotcnt_t size) {
	object_pointer *blockbegin = (object_pointer*) ((char*)heap_begin +
			( (unsigned int) bstart * (unsigned int) HEAPDESC.slotSize));
	keso_gc_slotcnt_t refsize = (keso_gc_slotcnt_t)
		(((unsigned int) size * (unsigned int) HEAPDESC.slotSize)/(unsigned int) sizeof(object_pointer));
	keso_gc_slotcnt_t index = 0;
	keso_gc_slotcnt_t objbegin=index;
	object_pointer obj;
	keso_gc_slotcnt_t objsize;
	keso_gc_slotcnt_t objwordsize;

	if(keso_olt_free_buffer_exhausted()) return;

	while(index < refsize) {
		if( (((unsigned int) blockbegin[index])&1) == 0 ) { index++; continue; }

		obj = (object_pointer)(blockbegin+index);

		ASSERTCLASSID(obj->class_id);

		KESO_ASSERT(CLS_ROFF(obj->class_id)==(index-objbegin));

		/* call tracer */
		keso_olt_free(obj); //TODO only diff between callFinalize and traceFreedObjects
		if(keso_olt_free_buffer_exhausted()) return;

		/* position behind found object */
		objsize = keso_objSize(HEAPDESC.slotSize,obj);
		objwordsize = objsize * (HEAPDESC.slotSize/sizeof(object_pointer));
		objbegin += objwordsize;
		index = objbegin;
	}

	KESO_ASSERT(index == refsize && index == objbegin);
}
#	else /*KESO_TRACE_OLT_INACCURATE_FREE*/
static void traceFreedObjects(keso_gc_slotcnt_t bstart, keso_gc_slotcnt_t size) {
	object_pointer *blockbegin = (object_pointer*) ((char*)heap_begin +
			( (unsigned int) bstart * (unsigned int) HEAPDESC.slotSize));
	keso_gc_slotcnt_t sizeb = (keso_gc_slotcnt_t)
		(((unsigned int) size * (unsigned int) HEAPDESC.slotSize));
	keso_olt_free(blockbegin,sizeb);	
}
#	endif /*KESO_TRACE_OLT_INACCURATE_FREE*/

#	define KESO_OLT_SEARCH_MISS_COUNTER_BEGIN { unsigned keso_olt_search_miss_counter = 0;
#	define KESO_OLT_SEARCH_MISS_COUNTER_INC (++keso_olt_search_miss_counter)
#	define KESO_OLT_SEARCH_MISS_COUNTER_END keso_olt_search_misses_add(keso_olt_search_miss_counter); }
#	define KESO_OLT_SEARCH_MISSES_ADD(V) keso_olt_search_misses_add(V)
#else
#	define KESO_OLT_SEARCH_MISS_COUNTER_BEGIN {
#	define KESO_OLT_SEARCH_MISS_COUNTER_INC
#	define KESO_OLT_SEARCH_MISS_COUNTER_END }
#	define KESO_OLT_SEARCH_MISSES_ADD(V)
#endif


#ifdef KESO_GC_STATS
	#define KESO_GC_STATS_INC_ALLOC_TRIES(domain) do { SuspendAllInterrupts(); (domain)->hd.gc_stats_alloc_tries++; ResumeAllInterrupts(); } while(0)
	#define KESO_GC_STATS_ADD_ALLOC(domain, bytes) do { SuspendAllInterrupts();\
			(domain)->hd.gc_stats_allocs++; (domain)->hd.gc_stats_allocated_memory += bytes;\
		ResumeAllInterrupts(); } while(0)
	#define KESO_GC_STATS_COND_INC_FREE_MEM_LIST_NEXT(domain, condition) do { if(condition) { SuspendAllInterrupts();\
			(domain)->hd.gc_stats_free_mem_list_next++;\
		ResumeAllInterrupts(); } } while(0)
#else
	#define KESO_GC_STATS_INC_ALLOC_TRIES(domain) ((void)0)
	#define KESO_GC_STATS_ADD_ALLOC(domain, bytes) ((void)0)
	#define KESO_GC_STATS_COND_INC_FREE_MEM_LIST_NEXT(domain, condition) ((void)0)
#endif


#if !defined(KESO_GC_LOG_MARK)
	#define GC_LOG_MARK_ACTIVATION()
	#define GC_LOG_MARK_SCAN_STACKS(did) ((void)0)
	#define GC_LOG_MARK_ROOTSET(did) ((void)0)
	#define GC_LOG_MARK_LIVING_HEAP_OBJECTS(did) ((void)0)
#endif


#include "keso_types.h"
#include "keso_config_flags.h"

/*
 * The need of a domain for a GC is determined by
 * the slots allocated since the last garbage collection (sasls)
 * compared to the remaining space. The remaining
 * space should not be less than the sasls plus a grace
 * area of 25% of the heap size. Thus, the "need" is calculated
 * freeslots - sasls - (heapsize>>2).
 * The function goes RoundRobin through the domain array and chooses
 * the first found domain that violates the above criterium (need<0). By
 * doing this instead of simply choosing the domain with the most severe
 * need, we can assure that all domains that have a need actually receive
 * a garbage collection (fairness to some degree).
 * If every domain has need>=0, the domain with the lowest need is taken.
 */

/*calculate need for a gc-run*/
static signed int keso_gc_need(void) {
	signed int need;
	need = DOMAINID()->heap_free - HEAPDESC.sasls - (DOMAINID()->heap_size>>2);
#ifdef KESO_ALLOW_FORCE_GC_NEED
	if(need >= 0) {
		if(DOMAINID()->force_gc_need) {
			need = -1;
		}
	}
#endif
	return need;
}

#ifdef KESO_ALLOW_FORCE_GC_NEED
#include "domains.h"
#define KESO_FORCE_GC_NEED_RESET() DOMAINID()->force_gc_need = 0
void keso_force_gc_need() {
	KESO_CURRENT_DOMAIN_GET->force_gc_need = 1;
	/*reactivate gc if it is in GCTMode "Lazy"*/
	#ifndef KESO_GCMODE_WORKAHOLIC
	if(0<keso_gctpaused) {
		keso_gctpaused=0;
		ActivateTask(keso_gc_task);
	}
	#endif
}
#else
#define KESO_FORCE_GC_NEED_RESET() ((void)0)
#endif


#define GC_LOCK_IF_FORCED() ((void)0)
#define GC_UNLOCK_IF_FORCED() ((void)0)

#define GC_LOCK() SuspendOSInterrupts()
#define GC_UNLOCK() ResumeOSInterrupts()
#define GC_LOCK_STACK()
#define GC_UNLOCK_STACK()
#define GC_LOCK_MUTATOR()
#define GC_UNLOCK_MUTATOR()

/** remove all elements */
static void coffee_list_clear(coffee_listel_t **pfreemem) {
	*pfreemem = NULL;
}

/** add an element to the list */
static coffee_listel_t **coffee_list_add(coffee_listel_t **prev_free, coffee_listel_t *block) {

#ifdef KESO_GC_STATS
	((struct domain_coffee_t *) KESO_CURRENT_DOMAIN_GET)->hd.gc_stats_free_mem_list_adds++;
#endif

	*prev_free = block;
	(*prev_free)->next = NULL;

	return &((*prev_free)->next);

}


/*
 * Allocator function of the COFFEE Heap.
 *
 * Returns a pointer to a free memory area on the
 * heap of the current domain with @size bytes.
 *
 * Throws an error if no suitable memory block can
 * be found.
 */
object_pointer keso_coffee_alloc(class_id_t class_id, obj_size_t bytesize, obj_size_t roff GC_LOG_INFO_PARAMETER) {
	struct domain_coffee_t *domain;
	coffee_listel_t **prev_ptr;
	coffee_listel_t *slot;
	object_pointer obj;
	obj_size_t size;

	domain = (struct domain_coffee_t *) KESO_CURRENT_DOMAIN_GET;
	size = BYTES2SLOTS(bytesize, domain->hd.slotSize);

#ifdef KESO_GC_STATS
	domain->hd.gc_stats_allocs++;
#endif

#ifdef KESO_GCMODE_ENFORCEONDEMAND
	do {
		GC_LOCK();

		GC_LOG_ACTIVATION_ALLOC();
		GC_LOG_ALLOC_START_EVENT(domain, domain->heap_free);
		GC_LOG_ALLOC_EVENT(KESO_CURRENT_TASK, GC_LOG_INFO, class_id, domain->heap_free, size);

		KESO_OLT_SEARCH_MISS_COUNTER_BEGIN;
		for (prev_ptr = &(domain->hd.freemem);*prev_ptr!=NULL;prev_ptr=&((*prev_ptr)->next)) {
			if ((*prev_ptr)->size>=size) break;
			KESO_OLT_SEARCH_MISS_COUNTER_INC;
		}
		KESO_OLT_SEARCH_MISS_COUNTER_END;

		if (unlikely(*prev_ptr==NULL)) {
			GC_UNLOCK();
		        GC_LOG_OUT_OF_MEMORY(domain, domain->heap_free);

			KESO_WAIT_FOR_GCRUN_EVENT();

			if (domain->hd.freemem==NULL)
				KESO_THROW_ERROR("out_of_memory\n");
			continue;
		}

		break;
	} while (1);
#else
	GC_LOCK();

	GC_LOG_ACTIVATION_ALLOC();
	GC_LOG_ALLOC_START_EVENT(domain, domain->heap_free);
	GC_LOG_ALLOC_EVENT(KESO_CURRENT_TASK, GC_LOG_INFO, class_id, domain->heap_free, size);

	KESO_OLT_SEARCH_MISS_COUNTER_BEGIN;
	for (prev_ptr = &(domain->hd.freemem);*prev_ptr!=NULL;prev_ptr=&((*prev_ptr)->next)) {
		if ((*prev_ptr)->size >= size) break;

#ifdef KESO_GC_STATS
		domain->hd.gc_stats_free_mem_list_next++;
#endif

		KESO_OLT_SEARCH_MISS_COUNTER_INC;
	}
	KESO_OLT_SEARCH_MISS_COUNTER_END;

	if (*prev_ptr==NULL) {
		 GC_UNLOCK();
		 GC_LOG_OUT_OF_MEMORY(domain, domain->heap_free);
		 KESO_THROW_ERROR("out_of_memory");
	}
#endif
	slot = *prev_ptr;

#ifdef KESO_GC_STATS
	domain->hd.gc_stats_requested_memory += bytesize;
	domain->hd.gc_stats_allocated_slots += size;
	domain->hd.gc_stats_allocated_memory += size * domain->hd.slotSize;
#endif

#ifdef KESO_HEAP_HAS_TINY_SLOTS
	/*
	 * Don't split the block if the rest is smaller than
	 * the free list header. Just give it away.
	 */
	if (slot->size > size && (slot->size - size) * domain->hd.slotSize >= sizeof(coffee_listel_t)) {
#else
	if (slot->size > size) {
#endif
		/* split block */
		slot->size -= size;
		slot = (coffee_listel_t *)((char *) slot + (slot->size * domain->hd.slotSize));
	} else {
		/* unlink block */
		*prev_ptr = slot->next;
	}

	{
		int sizeints,*tmp = (int *) slot;
		for(sizeints = size*domain->hd.slotSize/sizeof(int); sizeints>0; sizeints--)
			*(tmp++) = 0;
	}

	obj = (object_pointer) ((object_pointer *) slot + roff);
	obj->class_id=class_id;
	/* assumes that bit 0 in colorbit is always set!! */
	COLOROBJ(obj,domain->colorbit);

	domain->hd.sasls += size * domain->hd.slotSize;
	domain->heap_free -= size * domain->hd.slotSize;

	GC_LOG_ALLOC_END_EVENT(domain, domain->heap_free);
	GC_UNLOCK();

#ifdef KESO_DOUBLEBUFFERED_GC_BITMAP
	keso_bmp_double_markBackbuffer(slot - domain->hd.heap_top, size);
#endif
#ifdef KESO_TRACE_OLT
	keso_olt_alloc_internal(obj, class_id, bytesize, roff);
#endif
#ifdef KESO_USE_CODED_REFS_HEADER_CHECK
	KESO_INIT_PARITY_HEADER(obj);
#endif

#ifndef KESO_GCMODE_WORKAHOLIC
	if (0<keso_gctpaused) {
		keso_gctpaused=0;
		ActivateTask(keso_gc_task);
	}
#endif

	return obj;
}

#ifdef KESO_DOUBLEBUFFERED_GC_BITMAP
	static void keso_bmp_double_lock() { GC_LOCK(); }
	static void keso_bmp_double_unlock() { GC_UNLOCK(); }
#endif


#include "keso_types.h"
#ifdef KESO_OBJECTARRAYCLASS_AVAILABLE
#include "object_array.h"
#endif

#include "keso_parity.h"
#if 0
#	ifndef KESO_CHECK_AND_DECODE_REFERENCE
#		define KESO_CHECK_AND_DECODE_REFERENCE(_obj_, _method_, _bcpos_, _chkid_) (_obj_)
	// can't use CHECK_AND_DECODE, yet:
	// 1. CHECK_AND_DECODE is not idempotent.
	// 2. STATICREF and rootset are not encoded, yet.
	// 3. local references (stack) are not encoded.
	// --> GC does no parity-checks.
#	endif
#endif

#ifdef KESO_USE_LDS
extern char __keso_glob_start[];
extern char __keso_glob_end[];
#endif

/* Index of the next free slot on the stack (one above
 * the top element of the stack) */
static keso_gc_slotcnt_t keso_coffee_sp;

/* very conservative estimation of the maximum number of objects that might be allocated */
static object_pointer keso_coffee_stack[KESO_GC_WORKINGSTACK_SIZE];

/* internal functions */
static void keso_coffee_sweep(void);

static void keso_coffee_scanObject(object_pointer);
static void keso_coffee_pushObject(object_pointer);

static signed int keso_gc_need(void);

/* This is the main GC function of the COFFEE Heap.
 * The task is chaining itself and run periodically,
 * collection garbage on the heap of one domain at
 * each run.
 */

int keso_coffee_main(keso_umachineword_t did) {

	SET_DDESC(did);

	GC_LOG_ACTIVATION();

	if (keso_gc_need()<=0) {
		unsigned int i;
		unsigned int heap_size;

		/* we stop the whole world for the mark phase */
		GC_LOCK();

		GC_LOG_START_EVENT(DOMAINID(), DOMAINID()->heap_free);

#ifdef KESO_GC_STATS
		DOMAINID()->hd.gc_stats_runs++;
#endif

#ifdef KESO_NEED_FINALIZE
#if KESO_NUM_JAVADOMAINS > 1
		KESO_CURRENT_DOMAIN_SET( (domain_t*) DOMAINID() );
#endif
#endif

		/* heap begin and end are e.g. used to determine if an object reference is
		 * on the domain heap or not */
		heap_size = DOMAINID()->heap_size;
		heap_begin = (object_pointer) HEAPDESC.heap_top;
		heap_end = (object_pointer) ((char*) heap_begin + heap_size);

		keso_coffee_sp=0;

		/* toggle the color bit; all objects allocated up to know have been colored
		 * with the previous value; all discovered objects will be recolored with the
		 * new value
		 */
		DOMAINID()->colorbit ^= COLORBIT;

		/* record new allocations from this point */
		HEAPDESC.sasls = 0;

		/* Scan statics */
#if KESO_NUM_STATIC_REFS > 0
		for(i=0; i<KESO_NUM_STATIC_REFS; i++ ) {
#ifdef KESO_DEBUG_TRACE_REFERENCES
		  KESO_PRINTF("Found static reference at address 0x%x ", &(STATICREF(DOMAINID())[i]));
#endif
		  keso_coffee_pushObject((object_pointer)STATICREF(DOMAINID())[i]);
		}
#endif

		/* push root set */
#if KESO_GC_ROOTSETSIZE > 0
		for(i=0; i<KESO_GC_ROOTSETSIZE; i++) {
#ifdef KESO_DEBUG_TRACE_REFERENCES
		  KESO_PRINTF("Found immortal obj reference at address 0x%x ", &(HEAPDESC.rootset[i]));
#endif
		  keso_coffee_pushObject(HEAPDESC.rootset[i]);
		}
#endif

		/* scan stacks and tasks */
#if NUM_BLOCKING_TASKS > 0
		for(i=0; i < NUM_BLOCKING_TASKS; i++) {
#ifdef KESO_DEBUG_TRACE_REFERENCES
			KESO_PRINTF("Processing task %d ", i);
			int k=0;
#endif
			/* look through all stack partitions */
			keso_stack_simple_t *head = ((keso_stack_simple_t *) blocking_tasks[i]->_stack);
			for (KESO_CONST keso_stack_simple_t *stack = head; stack != NULL; stack = (keso_stack_simple_t *)stack->next) {
#ifdef KESO_DEBUG_TRACE_REFERENCES
			  KESO_PRINTF("Processing stack %d\n", k);
			  k++;
#endif
			  	/* scan llref if the current partition belongs to the gc'ed domain */
				if (stack->domain == (domain_t*) DOMAINID()) {
					keso_gc_walk_stack(stack->llrefs, keso_coffee_pushObject);
				}
			}
		}
#endif

		/* The root set is on the working stack now, scan and mark
		 * the objects until the working stack is empty */
#ifdef KESO_DEBUG_TRACE_REFERENCES
		KESO_PRINTF("Rootset is pushed\n");
#endif
		while (keso_coffee_sp>0) {
			keso_coffee_scanObject(keso_coffee_stack[--keso_coffee_sp]);
		}

		GC_LOG_MARK_END_EVENT(DOMAINID(), DOMAINID()->heap_free);

		/* keso_coffee_sweep heap */
		keso_coffee_sweep();

		GC_LOG_SWEEP_END_EVENT(DOMAINID(), DOMAINID()->heap_free);

		/* we wake up the whole world */

		GC_UNLOCK();

		/* KESO_SEND_GCRUN_EVENTS(); */

		/* clear bitmap for next run */
		keso_gc_clearBitmap();

		GC_LOG_CLEAR_END_EVENT(DOMAINID(), DOMAINID()->heap_free);

		return 1;
	} else {
		/* fall thru, we have nothing to do! */
		return 0;
	}
}

/*
* Scan the references of a object from the working stack and mark the
* object as living.
*/
static void keso_coffee_scanObject(object_pointer obj) {
	signed int curref;

	obj = NATIVE_ADDR_EXPLICIT(obj); //KESO_CHECK_AND_DECODE_REFERENCE(obj,__FUNCTION__, -1, -1);
	if (obj == (void *) 0) {
#ifdef KESO_DEBUG_TRACE_REFERENCES
	   KESO_PRINTF("points to NULL\n");
#endif
	  return;
	}
	curref = refCnt(obj);
#ifdef KESO_DEBUG_TRACE_REFERENCES
	KESO_PRINTF("points to object %d with %d references\n", (obj)->class_id, curref);
#endif
	while (curref<0) keso_coffee_pushObject( ((object_pointer*)obj)[curref++] );
#ifdef KESO_OBJECTARRAYCLASS_AVAILABLE
	while (curref>0) keso_coffee_pushObject( ((object_array_t*)obj)->data[--curref] );
#endif
	/* Finally, mark the object's bits in the bitmap */
	keso_gc_markObj(obj);
}


/* Push a white object on the stack.
 * If the object is not white, this function
 * will do nothing.
 *
 * THIS IS THE ONLY PLACE WHERE OBJECTS ARE PUSHED
 * ON THE WORKING STACK.
 */
static void keso_coffee_pushObject(object_pointer obj) {
	obj = NATIVE_ADDR_EXPLICIT(obj);
	if (obj == (void *) 0) return;
	ASSERTOBJ(obj);
#ifdef KESO_DEBUG_TRACE_REFERENCES
 	KESO_PRINTF("coffee stack: push reference at 0x%x points to object with id %d\n", &obj, obj->class_id);
#endif
#ifdef KESO_USE_LDS
	if (obj >= (object_pointer)__keso_glob_start && obj < (object_pointer)__keso_glob_end) {
		return;
	}
#endif

#ifdef KESO_IGNORE_COLOR
	if (OBJCOLORED(obj, GC_IGNORE))
		return;
#endif

	if (! OBJCOLORED(obj,DOMAINID()->colorbit)) {
		COLOROBJ(obj,DOMAINID()->colorbit);
		keso_coffee_stack[keso_coffee_sp++] = obj;
	}
}

/**
 * keso_coffee_sweep()
 *
 * - scan bitmap for free slots
 * - create a new free list
 */
static void keso_coffee_sweep() {
	const keso_gc_slotcnt_t numslots = DOMAINID()->heap_size / HEAPDESC.slotSize;
	coffee_listel_t **prev_free;
	keso_gc_slotcnt_t cur_slot = 0;

#ifdef KESO_GC_STATS
	int heap_free_before = DOMAINID()->heap_free;
#endif

	/* reset free list */
	coffee_list_clear(&(HEAPDESC.freemem));
	DOMAINID()->heap_free=0;

	prev_free = &HEAPDESC.freemem;

#ifdef	KESO_TRACE_OLT
	keso_olt_next_phase();
#endif

	while (cur_slot < numslots) {
		unsigned int blocksize;
		keso_gc_slotcnt_t size = keso_gc_findFreeBlock(&cur_slot, numslots - cur_slot);

		blocksize = size * HEAPDESC.slotSize;

		if (size > 0) {
			coffee_listel_t *block = (coffee_listel_t *) SLOT2ADDR(cur_slot);
#ifdef DEBUG
			int *tmp = (int *) block;
			unsigned int sizeints;
			/* fill free memory with 0xDEADBEEF to produce a segfault on usage */
			for(sizeints = blocksize/sizeof(int); sizeints>0; sizeints--)
				*(tmp++) = 0xDEADBEEF;
#endif

#ifdef KESO_HEAP_HAS_TINY_SLOTS
			/*
			 * Add the free block to the free list if the block size is great
			 * enough to store the list header, otherwise give it away.
			 */
			if (blocksize>=sizeof(coffee_listel_t)) {
#endif

				/* Insert new node */
				block->size = size;
				prev_free = coffee_list_add(prev_free,block);
				DOMAINID()->heap_free += blocksize;

#ifdef KESO_HEAP_HAS_TINY_SLOTS
			}
#endif

#ifdef KESO_TRACE_OLT
			traceFreedObjects(cur_slot, size);
#endif

			cur_slot += size;
		}
	}

#ifdef KESO_GC_STATS
	DOMAINID()->hd.gc_stats_recovered_memory += (DOMAINID()->heap_free - heap_free_before);
#endif

}



