// ****************************************************************
// TaskList Implementation
// ****************************************************************

namespace os { namespace scheduler {

/* Simpler array based task queue */
struct TaskList : public TaskListStatic {
    // encoded task priorities
    {{{snippet:ready_flag:name,A,B|Encoded_Static<%(A)s, %(B)s> %(name)s;}}}
    {{{generate:ready_flag_variables}}}

    // idle task id/priority
    static constexpr auto idle_id   = EC({{{generate:idle_id_sig}}}, 0);
    static constexpr auto idle_prio = EC({{{generate:idle_prio_sig}}}, 0);

    {{{snippet:ready_flag_init:name|, %(name)s(0,0)}}}
    TaskList() : TaskListStatic(){{{generate:ready_flag_constructor}}} {}

    /** Set priority of task id to prio **/
    // returns an encoded 0 with the signature (B) of the modified task - prio.B
    template<typename T, typename S>
    forceinline value_coded_t set(const T id, const S prio) {
{{{snippet:task_set_entry:name|if(id == %(id)s) {
    %(name)s = prio;
    return (%(name)s - prio).getCodedValue();
} else }}}

         {{{generate:task_set_call}}}{
             assert(false);
             return 0;
         }
    }

    template<typename T, typename S>
    forceinline value_coded_t head(T& id, S& prio) const {
        // initialize control flow signature
        static volatile value_coded_t signature;

		const value_coded_t signature0 = {{{generate:head_signature_vc}}};
        signature = signature0;

        // start with idle id/priority
        id = idle_id;
        prio = idle_prio;

        // add initial signature
        id.vc   += {{{generate:head_signature_vc}}};
        prio.vc += {{{generate:head_signature_vc}}};

{{{snippet:head_update_max:task,last_sig,next_sig,task_id_sig,i,ii|
// %(task)s >= prio?
signature += updateMax<%(last_sig)s, %(next_sig)s>(prio, %(task)s, id, EC(%(task_id_sig)s, %(task_id)s));
const value_coded_t signature%(ii)s = signature%(i)s + updateMax_signature(%(next_sig)s, prio, %(task)s);
assert(((signature - signature%(ii)s) %% S::A) == 0);
}}}
{{{snippet:head_update_idle_prio:last_sig,next_sig,i,ii|
//  restore idle_id if idle_id >= prio
signature += updateMax<%(last_sig)s, %(next_sig)s>(prio, idle_prio, id, idle_id);
const value_coded_t signature%(ii)s = signature%(i)s + updateMax_signature(%(next_sig)s, prio, idle_prio);
assert(((signature - signature%(ii)s) %% S::A) == 0);
}}}
        {{{generate:head_update_max_cascade}}}

        // subtract last signature
        id.vc   -= {{{generate:head_signature_vc}}};
        prio.vc -= {{{generate:head_signature_vc}}};

        // check signatures
        assert(id.check());
        assert(prio.check());

        debug << "head: " << id.decode() << " (prio " << prio.decode() << ")" << endl;

        return signature;
    }

    template<typename T, typename S>
    forceinline value_coded_t insert(const T& id, const S& prio) {
        debug << "+++ Task " << id.decode() << " with priority " << prio.decode() << " is ready" << endl;
        return set(id, prio);
    }

    template<typename T>
    forceinline value_coded_t remove(const T& id) {
        debug << "--- Task " << id.decode() << " removed from task queue" << endl;
        // The signature here is arbitrary, and won't be exposed.
        return set(id, EC(3, 0));
    }

    template<typename T, typename S>
    forceinline value_coded_t promote(const T& id, const S& newprio) {
        debug << "^^^ Promoting task " << id.decode() << " to priority " << newprio.decode() << endl;

        return set(id, newprio);
    }

    /* unused by scheduler
    template<typename T, typename S>
    forceinline value_coded_t dequeue(T& id, S& prio) {
        static value_coded_t sig1;

        sig1 = head(id, prio);

        value_coded_t sig2;
        if(prio != idle_prio) {
            sig2 = remove(id);
            // IDEA: set id.vc += sig2 + X; ?
        } else {
            // IDEA: set id.vc = sig2 + X; ?
			// The 42 here is choosen by fair dice roll
            sig2 = 42;
        }

        // TODO: more control flow checks?

        return sig1+sig2;
    }
    */
};

constexpr Encoded_Static<A0, {{{generate:idle_id_sig}}}> TaskList::idle_id;
constexpr Encoded_Static<A0, {{{generate:idle_prio_sig}}}> TaskList::idle_prio;

}; // scheduler
}; // os
