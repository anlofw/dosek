// ****************************************************************
// TaskList Implementation
// ****************************************************************

namespace os { namespace scheduler {

/* Simpler array based task queue */
struct TaskList : public TaskListStatic {
    typedef uint8_t id_t;

	// encoded task priorities
	{{{snippet:ready_flag:name,A,B|Encoded_Static<%(A)s, %(B)s> %(name)s;}}}
	{{{generate:ready_flag_variables}}}

	// idle task id/priority
	static constexpr auto idle_id   = EC({{{generate:idle_id_sig}}}, 0);
	static constexpr auto idle_prio = EC({{{generate:idle_prio_sig}}}, 0);

	{{{snippet:ready_flag_init:name|, %(name)s(0)}}}
	TaskList() : TaskListStatic(){{{generate:ready_flag_constructor}}} {}

	/** Set priority of task id to prio **/
	// returns an encoded 0 with the signature (B) of the modified task - prio.B
	forceinline value_coded_t isReady(const id_t id) {
		{{{snippet:task_get_entry:name|if(id == %(id)s) {
			return ((uint32_t)%(name)s.getCodedValue())
				^ ((uint32_t)EC(decltype(%(name)s)::B, 0).getCodedValue());
} else }}}

		{{{generate:task_set_call:task_get_entry}}}{
			assert(false);
			return 0;
		}
	}

	/** Set priority of task id to prio **/
	// returns an encoded 0 with the signature (B) of the modified task - prio.B
	template<typename S>
	forceinline value_coded_t set(const id_t id, const S prio) {
{{{snippet:task_set_entry:name|if(id == %(id)s) {
	%(name)s = prio;
	return (%(name)s - prio).getCodedValue();
} else }}}

		 {{{generate:task_set_call:task_set_entry}}}{
			 assert(false);
			 return 0;
		 }
	}

	/** Set priority of task id to prio **/
	// returns an encoded 0 with the signature (B) of the modified task - prio.B
	template<typename S>
	forceinline value_coded_t increasePrio(const id_t id, const S newprio) {
		{{{snippet:task_increasePrio_entry:name|if(id == %(id)s) {
	%(name)s.vc += 10;
	updateMax<10, 11>(%(name)s, newprio);
	%(name)s.vc -= 11;
	value_coded_t ret = (%(name)s - newprio).getCodedValue();
	if ((ret %% A0) != (decltype(%(name)s)::B - decltype(newprio)::B)) {
		CALL_HOOK(FaultDetectedHook, ANBdetected, 0, 0);
	}
	return ret;
} else }}}

		{{{generate:task_set_call:task_increasePrio_entry}}}{
			assert(false);
			return 0;
		}
	}

	template<typename T, typename S>
	forceinline value_coded_t head(T& id, S& prio) const {
		B_t sigId = id.getB();
		B_t sigPrio = prio.getB();

		bool first = true;

{{{snippet:head_update_max:task,last_sig,next_sig,task_id_sig,i,ii|
if(first) {
	first=false;
	sigId += %(next_sig)s;
	sigPrio += %(next_sig)s;
	id.vc = Encoded::encode(%(task_id)s, A0, sigId, 0);
	prio.vc = %(task)s.vc + (sigPrio - %(task)s.getB());
} else {
	// %(task)s >= prio?
	updateMax(sigPrio, sigId, %(next_sig)s, &prio, %(task)s, &id, EC(%(task_id_sig)s, %(task_id)s));

	if ((prio.vc + id.vc) %% A0 != (sigPrio + sigId)) {
#ifdef RETRYSCHED
        return 42;
#else
		CALL_HOOK(FaultDetectedHook, ANBdetected, prio.vc, id.vc);
#endif
	}

	/* Recode if sigID got too big */
	if (sigId > A0 / 2) {
		id.vc = id.vc - sigId + 3;
		sigId = 3;
	}
}
}}}
{{{snippet:head_update_idle_prio:last_sig,next_sig,i,ii|
if(first) {
	first=false;
	id=idle_id;
	prio=idle_prio;
} else {
	// restore idle_id if idle_id >= prio
	updateMax(sigPrio, sigId, %(next_sig)s, &prio, idle_prio, &id, idle_id);

	// last comparison, needs no assert
}
}}}
		{{{generate:head_update_max_cascade}}}

		pseudo_static_assert(!first, "no task possible");

		pseudo_static_assert(sigId > 0, "constant sigId not optimized away completely");
		pseudo_static_assert(sigPrio > 0, "constant sigPrio not optimized away completely");

		id.vc -= (sigId - id.getB());
		prio.vc -= (sigPrio - prio.getB());

		return 0;
	}

	template<typename NewPrio>
		forceinline value_coded_t insert(const id_t id, const NewPrio &newprio) {

		return increasePrio(id, newprio);
	}

	forceinline value_coded_t remove(const id_t id) {
		// The signature here is arbitrary, and won't be exposed.
		return set(id, EC(3, 0));
	}

	template<typename S>
	forceinline value_coded_t promote(const id_t id, const S& newprio) {
		return set(id, newprio);
	}

	void dump() {
		{{{snippet:dump_entry:name|debug << "%(name)s: " << %(name)s.decode() << endl;
}}}
		{{{generate:task_set_call:dump_entry}}}
	}
	/* unused by scheduler
	template<typename T, typename S>
	forceinline value_coded_t dequeue(T& id, S& prio) {
		static value_coded_t sig1;

		sig1 = head(id, prio);

		value_coded_t sig2;
		if(prio != idle_prio) {
			sig2 = remove(id);
			// IDEA: set id.vc += sig2 + X; ?
		} else {
			// IDEA: set id.vc = sig2 + X; ?
			// The 42 here is choosen by fair dice roll
			sig2 = 42;
		}

		// TODO: more control flow checks?

		return sig1+sig2;
	}
	*/
};

/** Equality operator (used for TMR) [enc=1] **/
bool operator==(const TaskList& lhs, const TaskList& rhs) {
		{{{snippet:eq_operator_snippet:name|if(lhs.%(name)s.vc != rhs.%(name)s.vc) return false;
}}}
		{{{generate:task_set_call:eq_operator_snippet}}}
        return true;
}

bool operator!=(const TaskList& lhs, const TaskList& rhs) { return !(lhs == rhs); }


constexpr Encoded_Static<A0, {{{generate:idle_id_sig}}}> TaskList::idle_id;
constexpr Encoded_Static<A0, {{{generate:idle_prio_sig}}}> TaskList::idle_prio;

}; // scheduler
}; // os
