namespace os {
namespace scheduler {

using namespace os::tasks;

{{{snippet:hint_arg:task,desc|, bool %(task)s = true}}}
{{{snippet:hint_body:task,desc|static const bool %(task)s_is_possible = %(task)s;
}}}

template<bool Idle = true{{{generate:foreach_subtask_snippet:hint_arg}}}>
struct SchedulerTargetHint {
    static const bool Idle_is_possible = Idle;
    {{{generate:foreach_subtask_snippet:hint_body}}}
};

struct Scheduler  {
    os::scheduler::TaskList tlist;

    //Encoded_Static<A0, {{{generate:current_prio_sig}}}> current_prio;
    //Encoded_Static<A0, {{{generate:current_task_sig}}}> current_task;
    Encoded_Static<A0, 121> current_prio;
    Encoded_Static<A0, 127> current_task;

    static constexpr auto scheduler_prio = EC({{{generate:scheduler_prio_sig}}}, {{{generate:scheduler_prio}}});

    template<typename TargetHint = SchedulerTargetHint<> >
    forceinline void Reschedule(void) {
        // TODO: control flow check
		//  tlist.dump();

        // OPTIMIZATION: do not reschedule if RES_SCHEDULER is taken
        if (current_prio != scheduler_prio) {
            // set current (=next) task from task list
            tlist.head<TargetHint>(current_task, current_prio);
        }
	assert(current_task.check());
	assert(current_prio.check());

        // dispatch or enter idle
        // TODO: generated signature
{{{snippet:reschedule_dispatch_task:task,desc|if(TargetHint::%(task)s_is_possible && current_task == %(desc)s.enc_id<1>()) {
    if (%(desc)s.preemptable == false) {
        // promote non-preemptable task to RES_SCHEDULER
        tlist.promote(%(desc)s.enc_id<1>(), scheduler_prio);
        current_prio = scheduler_prio;
    }
    Dispatcher::Dispatch(%(desc)s);
} else }}}
        {{{generate:foreach_subtask_snippet:reschedule_dispatch_task}}}if(TargetHint::Idle_is_possible && current_task == TaskList::idle_id) {
            Dispatcher::idle();
        } else {
            assert(false);
        }
    }

	template<int TASK_SIG = {{{generate:arbitrary_new_signature}}}>
    forceinline void SetReady_impl(const Task task) {
		IncreasePriority<TASK_SIG>(task, task.prio);
    }

    forceinline void Schedule_impl(void) {
        if(in_syscall()) {
            // in syscall: reschedule directly
            Reschedule();
        } else {
            // not in syscall (probably in ISR): request reschedule AST
            // Calls also Reschedule()
            request_reschedule_ast();
        }
    }

	template<int TASK_SIG = {{{generate:arbitrary_new_signature}}}>
    forceinline void SetSuspended_impl(const Task t) {
        t.tcb.reset();

        tlist.remove(t.enc_id<TASK_SIG>());
        if (t.preemptable == false) {
            // restore non-preemptable task to original priority
            // this is required for the optimization in Reschedule()
            current_prio = t.enc_prio<{{{generate:arbitrary_new_signature}}}>();
        }
    }

	template<int TO_SIG = {{{generate:arbitrary_new_signature}}}>
    forceinline void ActivateTask_impl(const Task to) {
		SetReady_impl<TO_SIG>(to);
		Schedule_impl();
    }

	template<int FROM_SIG, int TO_SIG>
    forceinline void ChainTask_impl(const Task from, const Task to) {
        auto from_id = from.enc_id<FROM_SIG>();
        assert(from_id == current_task);

        SetSuspended_impl<FROM_SIG>(from);
		SetReady_impl<TO_SIG>(to);
		Schedule_impl();
    }

    forceinline void TerminateTask_impl(const Task from) {
        auto id = from.enc_id<{{{generate:arbitrary_new_signature}}}>();
        assert(id == current_task);

        SetSuspended_impl(from);

        Schedule_impl();
    }

    forceinline void GetResource_impl(const Task current_task, const int new_prio) {
		SetPriority(current_task, new_prio);
		SetSystemPriority(new_prio);
    }

    forceinline void ReleaseResource_impl(const Task current_task, const int new_prio) {
		SetPriority(current_task, new_prio);
		SetSystemPriority(new_prio);
		Schedule_impl();
    }

    forceinline void SetReadyFromSuspended_impl(const Task task) {
		SetPriority(task, task.prio);
    }

	// Low level interface to the task list
	template<int TASK_SIG = {{{generate:arbitrary_new_signature}}}>
	forceinline void SetCurrentTask(const Task task) {
		if (task.preemptable == false) {
			// promote non-preemptable task to RES_SCHEDULER
			tlist.set(task.enc_id<1>(), scheduler_prio);
			current_prio = scheduler_prio;
		}
		current_task = task.enc_id<TASK_SIG>();
	}

	forceinline void SetSystemPriority(const int new_prio) {
		auto new_prio_encoded = EC(2, new_prio);
		current_prio = new_prio_encoded;
	}


	forceinline void SetPriority(const Task task, const int new_prio) {
		auto id = task.enc_id<1>();
		auto new_prio_encoded = EC(2, new_prio);
		tlist.set(id, new_prio_encoded);
	}

	forceinline bool isSuspended(const Task task) {
		auto id = task.enc_id<1>();
		return tlist.isSuspended(id);
	}


	template<int TASK_SIG = {{{generate:arbitrary_new_signature}}}>
	forceinline void IncreasePriority(const Task task, const int new_prio) {
	auto id = task.enc_id<TASK_SIG>();
        // TODO: generated signature
		{{{snippet:activate_task_task:task,id_sig,prio_sig,task_prio_sig|if (id == %(task)s.enc_id<1>()) {
	value_coded_t signature = tlist.insert(%(task)s.enc_id<%(id_sig)s>(), EC(%(prio_sig)s, new_prio));
	assert((signature - (%(task_prio_sig)s - %(prio_sig)s)) %% decltype(id)::A == 0);
} else }}}
        {{{generate:activate_task_foreach_task}}}{
            assert(false);
        }
	}
};

constexpr Encoded_Static<A0, {{{generate:scheduler_prio_sig}}}> Scheduler::scheduler_prio;
Scheduler scheduler_;


}; // namespace scheduler
}; // namespace os
