namespace os {
namespace scheduler {

using namespace os::tasks;

struct Scheduler  {
    os::scheduler::TaskList tlist;

    Encoded_Static<A0, {{{generate:current_prio_sig}}}> current_prio;
    Encoded_Static<A0, {{{generate:current_task_sig}}}> current_task;

    static constexpr auto scheduler_prio = EC({{{generate:scheduler_prio_sig}}}, {{{generate:scheduler_prio}}});

    noinline void Reschedule(void);


    forceinline void Schedule_impl(void) {
        if(in_syscall()) {
            // in syscall: reschedule directly
            Reschedule();
        } else {
            // not in syscall (probably in ISR): request reschedule AST
            // Calls also Reschedule()
            request_reschedule_ast();
        }
    }

	void forceinline SetReady_impl(const Task &task) {
		tlist.insert(task.id, EC(2, task.prio));
	}

	void forceinline SetSuspended_impl(const Task &t) {
		t.tcb.reset();

		tlist.remove(t.id);
		if (t.preemptable == false) {
			// restore non-preemptable task to original priority
			// this is required for the optimization in Reschedule()
			current_prio = t.enc_prio<{{{generate:arbitrary_new_signature}}}>();
		}
	}


    forceinline void ActivateTask_impl(const Task &to) {
		SetReady_impl(to);
		Schedule_impl();
    }

    forceinline void ChainTask_impl(const Task &from, const Task &to) {
        SetSuspended_impl(from);
		SetReady_impl(to);
		Schedule_impl();
    }

    forceinline void TerminateTask_impl(const Task &from) {
        SetSuspended_impl(from);
        Schedule_impl();
    }

    forceinline void GetResource_impl(const Task &current_task, const int new_prio) {
		SetPriority(current_task, new_prio);
		SetSystemPriority(new_prio);
    }

    forceinline void ReleaseResource_impl(const Task &current_task, const int new_prio) {
		SetPriority(current_task, new_prio);
		SetSystemPriority(new_prio);
		Schedule_impl();
    }

    forceinline void SetReadyFromSuspended_impl(const Task &task) {
		SetPriority(task, task.prio);
    }

	// Low level interface to the task list
	forceinline void SetCurrentTask(const Task &task) {
		if (task.preemptable == false) {
			// promote non-preemptable task to RES_SCHEDULER
			tlist.set(task.id, scheduler_prio);
			current_prio = scheduler_prio;
		}
		current_task = task.enc_id<1>();
	}

	forceinline void SetSystemPriority(const int new_prio) {
		auto new_prio_encoded = EC(2, new_prio);
		current_prio = new_prio_encoded;
	}


	forceinline void SetPriority(const Task &task, const int new_prio) {
		auto new_prio_encoded = EC(2, new_prio);
		tlist.set(task.id, new_prio_encoded);
	}

	forceinline bool isSuspended(const Task &task) {
		return tlist.isSuspended(task.id);
	}
};

void Scheduler::Reschedule(void) {
	// OPTIMIZATION: do not reschedule if RES_SCHEDULER is taken
	if (current_prio != scheduler_prio) {
		// set current (=next) task from task list
		tlist.head(current_task, current_prio);
	}
	current_task.check();
	current_prio.check();

	// dispatch or enter idle
	// TODO: generated signature
{{{snippet:reschedule_dispatch_task:task,desc|if(current_task == %(desc)s.enc_id<1>()) {
    if (%(desc)s.preemptable == false) {
        // promote non-preemptable task to RES_SCHEDULER
        tlist.promote(%(desc)s.id, scheduler_prio);
        current_prio = scheduler_prio;
    }
    Dispatcher::Dispatch(%(desc)s);
} else }}}
        {{{generate:foreach_subtask_snippet:reschedule_dispatch_task}}}if(current_task == TaskList::idle_id) {
            Dispatcher::idle();
        } else {
			CALL_HOOK(FaultDetectedHook, LOGIC_ERRORdetected, 0, 0);
        }
    }

constexpr Encoded_Static<A0, {{{generate:scheduler_prio_sig}}}> Scheduler::scheduler_prio;
Scheduler scheduler_;


}; // namespace scheduler
}; // namespace os
