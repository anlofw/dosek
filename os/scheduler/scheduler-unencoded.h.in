namespace os {
namespace scheduler {

using namespace os::tasks;

 {{{snippet:hint_arg:task,desc|, bool %(task)s = true}}}
 {{{snippet:hint_body:task,desc|static const bool %(task)s_is_possible = %(task)s;
		 }}}

template<bool Idle = true{{{generate:foreach_subtask_snippet:hint_arg}}}>
struct SchedulerTargetHint {
	static const bool Idle_is_possible = Idle;
	{{{generate:foreach_subtask_snippet:hint_body}}}
};

struct Scheduler {
    os::scheduler::TaskList tlist;

    typedef uint8_t prio_t;
    typedef uint8_t id_t;

    prio_t current_prio;
    id_t current_task;

    static constexpr prio_t scheduler_prio = {{{generate:scheduler_prio}}};

	template<typename TargetHint = SchedulerTargetHint<> >
    forceinline void Reschedule(void) {
        // OPTIMIZATION: do not reschedule if RES_SCHEDULER is taken
        if (current_prio != scheduler_prio) {
            // set current (=next) task from task list
            tlist.head<TargetHint>(current_task, current_prio);
        }

        // dispatch or enter idle
        // TODO: generated signature
{{{snippet:reschedule_dispatch_task:task,desc|if(TargetHint::%(task)s_is_possible && current_task == %(desc)s.id) {
    if (%(desc)s.preemptable == false) {
        // promote non-preemptable task to RES_SCHEDULER
        tlist.promote(%(desc)s.id, scheduler_prio);
        current_prio = scheduler_prio;
    }
    Dispatcher::Dispatch(%(desc)s);
} else }}}
        {{{generate:foreach_subtask_snippet:reschedule_dispatch_task}}}if(TargetHint::Idle_is_possible && current_task == TaskList::idle_id) {
            Dispatcher::idle();
        } else {
            assert(false);
        }
    }


    forceinline void SetReady_impl(const Task &task) {
		tlist.insert(task.id, task.prio);
    }


    forceinline void Schedule_impl(void) {
        if(in_syscall()) {
            // in syscall: reschedule directly
            Reschedule();
        } else {
            // not in syscall (probably in ISR): request reschedule AST
            // Calls also Reschedule()
            request_reschedule_ast();
        }
    }

    forceinline void SetSuspended_impl(const Task &t) {
        t.tcb.reset();

        tlist.remove(t.id);
        if (t.preemptable == false) {
            // restore non-preemptable task to original priority
            // this is required for the optimization in Reschedule()
            current_prio = t.prio;
        }
    }

    forceinline void ActivateTask_impl(const Task &task) {
		SetReady_impl(task);
        Schedule_impl();
    }

    forceinline void ChainTask_impl(const Task &from, const Task &to) {
        auto from_id = from.id;
        assert(from_id == current_task);

        SetSuspended_impl(from);
		SetReady_impl(to);
        Schedule_impl();
    }

    forceinline void TerminateTask_impl(const Task &from) {
        auto id = from.id;
        assert(id == current_task);

        SetSuspended_impl(from);

        Schedule_impl();
    }

    forceinline void GetResource_impl(const Task &current_task, const int new_prio) {
		SetPriority(current_task, new_prio);
		SetSystemPriority(new_prio);
    }

    forceinline void ReleaseResource_impl(const Task &current_task, const int new_prio) {
		SetPriority(current_task, new_prio);
		SetSystemPriority(new_prio);
        Schedule_impl();
    }


    forceinline void SetReadyFromSuspended_impl(const Task &task) {
		SetPriority(task, task.prio);
    }

	// Low level interface to the task list
	forceinline void SetCurrentTask(const Task &task) {
        if (task.preemptable == false) {
            // promote non-preemptable task to RES_SCHEDULER
            tlist.set(task.id, scheduler_prio);
            current_prio = scheduler_prio;
        }
		current_task = task.id;
	}

	forceinline void SetSystemPriority(const int new_prio) {
		current_prio = new_prio;
	}

	forceinline void SetPriority(const Task &task, const int new_prio) {
		tlist.set(task.id, new_prio);
	}

	forceinline bool isSuspended(const Task &task) {
		return tlist.isSuspended(task.id);
	}

};

constexpr Scheduler::prio_t Scheduler::scheduler_prio;
Scheduler scheduler_;

}; // scheduler
}; // os
